---
layout: post
title: Java YAML Shootout - SnakeYaml vs YamlBeans
date: 2012-04-26 08:50:34.000000000 -05:00
categories:
- Java
tags:
- java
- yaml
status: publish
type: post
published: true
meta:
  _edit_last: '25054220'
  publicize_results: a:2:{s:7:"twitter";a:1:{i:109154946;a:2:{s:7:"user_id";s:12:"adamnengland";s:7:"post_id";s:18:"195519506100129793";}}s:2:"fb";a:1:{i:1471181839;a:2:{s:7:"user_id";s:10:"1471181839";s:7:"post_id";s:13:"3796917009390";}}}
  _wpas_done_twitter: '1'
  _wpas_done_fb: '1'
  _wpas_done_linkedin: '1'
  _oembed_4ac9179a61d9938b2a1175cbedf23a6a: '{{unknown}}'
author:
  login: adamnengland
  email: adam.n.england@gmail.com
  display_name: adamnengland
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>After spending a couple months developing <a href="http://www.liveon.com">LiveOn</a> using the <a href="http://www.playframework.org/">Play! Framework</a>, I've grown increasingly intolerant of other Java frameworks.  While I'd used YAML before in Rails &amp; Python, Java frameworks usually ignore YAML in favor of XML for configuration.  The creators of Play! realized that XML sucked, and implemented their dependency, database, and routing configurations as YAML.</p>
<p>So, in the spirit of helping spread YAML around the Java world, I've taken a look at a few YAML libraries.  Lets see which one stacks up as the best bet for adding YAML support to your Java project.</p>
<p><strong><br />
</strong>The contenders</p>
<ul>
<li><a href="http://code.google.com/p/snakeyaml/">SnakeYml</a></li>
<li><a href="http://yamlbeans.sourceforge.net/">YamlBeans</a></li>
</ul>
<p><strong><em>Note:</em> </strong>I've ommited JYaml.  While it is an early implementation, and still a useful library, it is no longer maintained by its creator, and therefore not a realistic candidate.</p>
<p>The full code sample can be found here:  <a href="https://github.com/adamnengland/yaml-shootout">https://github.com/adamnengland/yaml-shootout</a></p>
<p><strong>Basic Usage  - </strong>For simple usage, its pretty much a wash.  Examples in both libraries look almost identical</p>
<p><span style="text-decoration:underline;">SnakeYaml</span></p>
<p>{% highlight java %}<br />
@Test<br />
public void testSimpleConfigurationLoad() throws Exception {<br />
  InputStream input = new FileInputStream(new File("src/test/resources/simpleConfig.yml"));<br />
  Map data = (Map) Yaml.load(input);<br />
  assertEquals("yaml-shootout", data.get("simple"));<br />
}<br />
{% endhighlight %}</p>
<p><span style="text-decoration:underline;">YamlBeans</span></p>
<p>{% highlight java %}<br />
@Test</p>
<p>public void testSimpleConfigurationLoad() throws Exception {<br />
  YamlReader reader = new YamlReader(new FileReader("src/test/resources/simpleConfig.yml"));<br />
  Map data = (Map) reader.read();<br />
  assertEquals("yaml-shootout", data.get("simple"));<br />
}<br />
{% endhighlight %}</p>
<p><strong>Parsing to a Bean - </strong>Once again, not much difference here.</p>
<p>SnakeYaml</p>
<p>{% highlight java %}<br />
@Test<br />
  @Test<br />
  public void testAdvancedConfigurationLoad() throws Exception {<br />
    InputStream input = new FileInputStream(new File("src/test/resources/advancedConfig.yml"));<br />
    YamlConfig data = (YamlConfig) Yaml.load(input);<br />
    assertEquals("yaml-shootout", data.simple);<br />
    assertEquals("gmail", data.advanced.type);<br />
  }<br />
{% endhighlight %}</p>
<p><span style="text-decoration:underline;">YamlBeans</span></p>
<p>{% highlight java %}<br />
  @Test<br />
  public void testAdvancedConfigurationLoad() throws Exception {<br />
    YamlReader reader = new YamlReader(new FileReader("src/test/resources/advancedConfig.yml"));<br />
    YamlConfig data = (YamlConfig) reader.read();<br />
    assertEquals("yaml-shootout", data.simple);<br />
    assertEquals("gmail", data.advanced.type);<br />
  }<br />
{% endhighlight %}</p>
<p><strong>Extra Features</strong></p>
<ul>
<li>Both Libraries support serialization (with a similar, simple syntax)</li>
<li>Both Libraries support deserialization into maps, lists, and Strings</li>
<li>Both Libraries support Tags &amp; Shortcuts</li>
<li>SnakeYaml supports YAML's <a href="http://yaml.org/type/merge.html">merge</a> specification.</li>
</ul>
<p><strong>Community</strong></p>
<p>Here, SnakeYaml starts to get the edge.  Both <a href="http://code.google.com/p/snakeyaml/">SnakeYaml</a> and <a href="http://code.google.com/p/yamlbeans/">YamlBeans</a> are hosted on google code.</p>
<table>
<tbody>
<tr>
<td></td>
<td>SnakeYaml</td>
<td>YamlBeans</td>
</tr>
<tr>
<td>Starred By</td>
<td>118 users</td>
<td>24 users</td>
</tr>
<tr>
<td>Commiters</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>Google Group Messages</td>
<td>630</td>
<td>57</td>
</tr>
</tbody>
</table>
<p><strong>Finally</strong></p>
<p>Well, I have to say, I'm a little disappointed in the outcome.  I'd hoped for something a little more controversial when I started this experiment, but it appears that SnakeYaml &amp; YamlBeans are both excellent yaml frameworks for java, with a lot of the same syntax.  However, at the end of the day, SnakeYaml gets the edge for a larger feature set, and a much more active community</p>
