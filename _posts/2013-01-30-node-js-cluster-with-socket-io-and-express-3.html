---
layout: post
title: Clustering Web Sockets with Socket.IO and Express 3
date: 2013-01-30 08:10:43.000000000 -06:00
categories:
- Node.js
tags:
- coffeescript
- express
- node.js
- socket.io
- websockets
status: publish
type: post
published: true
meta:
  _edit_last: '25054220'
  _publicize_pending: '1'
  _wpas_done_881585: '1'
  _publicize_done_external: a:1:{s:8:"facebook";a:1:{i:1471181839;b:1;}}
  publicize_twitter_user: adamnengland
  _wpas_done_881586: '1'
  _wpas_done_881584: '1'
  _wpas_skip_881585: '1'
  _wpas_skip_881586: '1'
  _wpas_skip_881584: '1'
author: Adam N England
excerpt: <p><a href="http://nodejs.org/">Node.js</a> gets a lot of well-deserved press for its impressive performance. The event loop can handle pretty impressive loads with a single process. However, most servers have multiple processors, and I, for one, would like to take advantage of them. <a href="http://nodejs.org/api/cluster.html">Node's cluster api</a> can help.</p><p>While cluster is a core api in node.js, I'd like to incorporate it with <a href="http://expressjs.com/">Express 3</a> and <a href="http://socket.io/">Socket.io</a>.</p><p>Final source code available on <a href="https://github.com/adamnengland/node_cluster_socket_express">github</a></p>
---
<p><a href="http://nodejs.org/">Node.js</a> gets a lot of well-deserved press for its impressive performance. The event loop can handle pretty impressive loads with a single process. However, most servers have multiple processors, and I, for one, would like to take advantage of them. <a href="http://nodejs.org/api/cluster.html">Node's cluster api</a> can help.</p>
<p>While cluster is a core api in node.js, I'd like to incorporate it with <a href="http://expressjs.com/">Express 3</a> and <a href="http://socket.io/">Socket.io</a>.</p>
<p>Final source code available on <a href="https://github.com/adamnengland/node_cluster_socket_express">github</a></p>
<p>The node cluster docs gives us the following example.</p>
{% highlight javascript linenos%}
cluster = require("cluster")
http = require("http")
numCPUs = require("os").cpus().length
if cluster.isMaster
  i = 0
  while i < numCPUs     cluster.fork()     i++   cluster.on "exit", (worker, code, signal) ->
    console.log "worker " + worker.process.pid + " died"
else
  http.createServer((req, res) ->
    res.writeHead 200
    res.end "hello world\n"
  ).listen 8000
{% endhighlight %}</p>
<p>The code compiles and runs, but I have not confirmation that things are actually working. I'd like to add a little logging to confirm that we actually have multiple workers going. Lets add these lines right before the 'exit' listener.</p>
<p>{% highlight javascript %}
  cluster.on 'fork', (worker) ->
    console.log 'forked worker ' + worker.id
{% endhighlight %}
<p>On my machine, we get this output:
{% highlight bash %}
coffee server
forked worker 1
forked worker 2
forked worker 3
forked worker 4
forked worker 5
forked worker 6
forked worker 7
forked worker 8
{% endhighlight %}
<p>So far, so good. Lets add express to the mix.</p>
{% highlight javascript linenos %}
cluster = require("cluster")
http = require("http")
numCPUs = require("os").cpus().length
if cluster.isMaster
  i = 0
  while i < numCPUs     cluster.fork()     i++   cluster.on 'fork', (worker) ->
    console.log 'forked worker ' + worker.process.pid
  cluster.on "listening", (worker, address) ->
    console.log "worker " + worker.process.pid + " is now connected to " + address.address + ":" + address.port
  cluster.on "exit", (worker, code, signal) ->
    console.log "worker " + worker.process.pid + " died"
else
  app = require("express")()
  server = require("http").createServer(app)
  server.listen 8000
  app.get "/", (req, res) ->
    console.log 'request handled by worker with pid ' + process.pid
    res.writeHead 200
    res.end "hello world\n"
{% endhighlight %}</p>
<p>At this point, I'd like to throw a few http requests against the setup to ensure that I'm really utilizing all my processors.
Running (curl -XGET "http://localhost:8000") 6 times makes the node process go:</p>
{% highlight javascript %}
request handled by worker with pid 85229
request handled by worker with pid 85231
request handled by worker with pid 85231
request handled by worker with pid 85231
request handled by worker with pid 85227
request handled by worker with pid 85229
{% endhighlight %}
<p>Alright, last step is getting socket.io involved. Just a couple extra lines for the socket, however, we'll need to add a basic index.html file to actually make the socket calls.</p>
{% highlight javascript linenos %}
cluster = require("cluster")
http = require("http")
numCPUs = require("os").cpus().length
if cluster.isMaster
  i = 0
  while i < numCPUs     cluster.fork()     i++   cluster.on 'fork', (worker) ->
    console.log 'forked worker ' + worker.process.pid
  cluster.on "listening", (worker, address) ->
    console.log "worker " + worker.process.pid + " is now connected to " + address.address + ":" + address.port
  cluster.on "exit", (worker, code, signal) ->
    console.log "worker " + worker.process.pid + " died"
else
  app = require("express")()
  server = require("http").createServer(app)
  io = require("socket.io").listen(server)
  server.listen 8000
  app.get "/", (req, res) ->
    res.sendfile(__dirname + '/index.html');
  io.sockets.on "connection", (socket) ->
    console.log 'socket call handled by worker with pid ' + process.pid
    socket.emit "news",
      hello: "world"
{% endhighlight %}
<p>&nbsp;</p>

{% highlight html linenos %}
  <script class="hiddenSpellError" type="text/javascript">// <![CDATA[
  src</span>="/socket.io/socket.io.js">
  // ]]></script><script type="text/javascript">// <![CDATA[

  // ]]></script>
   var socket = io.connect('http://localhost');
   socket.on('news', function (data) {
   console.log(data);
   socket.emit('my other event', { my: 'data' });
   });
  // ]]></script>
{% endhighlight %}

<p>When I run this code, problems start to appear. Specifically, the following message shows up in my output</p>
<p><span style="color:#ff0000;">warn - client not handshaken client should reconnect</span></p>
<p>Not surprisingly, we have issues with sockets appearing disconnected. Socket.io defaults to storing its open sockets in an in-memory store. As a result, sockets in other processes have no access to the information. We can easily fix the problem by using the redis store for socket.io. The docs we need are <a href="https://github.com/LearnBoost/Socket.IO/wiki/Configuring-Socket.IO">here</a>.</p>
<p>With the redis store in place, it looks like this:</p>

{% highlight javascript linenos %}
cluster = require("cluster")
http = require("http")
numCPUs = require("os").cpus().length
RedisStore = require("socket.io/lib/stores/redis")
redis = require("socket.io/node_modules/redis")
pub = redis.createClient()
sub = redis.createClient()
client = redis.createClient()
if cluster.isMaster
  i = 0
  while i < numCPUs     cluster.fork()     i++   cluster.on 'fork', (worker) ->
    console.log 'forked worker ' + worker.process.pid
  cluster.on "listening", (worker, address) ->
    console.log "worker " + worker.process.pid + " is now connected to " + address.address + ":" + address.port
  cluster.on "exit", (worker, code, signal) ->
    console.log "worker " + worker.process.pid + " died"
else
  app = require("express")()
  server = require("http").createServer(app)
  io = require("socket.io").listen(server)
  io.set "store", new RedisStore(
    redisPub: pub
    redisSub: sub
    redisClient: client
  )
  server.listen 8000
  app.get "/", (req, res) ->
    res.sendfile(__dirname + '/index.html');
  io.sockets.on "connection", (socket) ->
    console.log 'socket call handled by worker with pid ' + process.pid
    socket.emit "news",
      hello: "world"
{% endhighlight %}
