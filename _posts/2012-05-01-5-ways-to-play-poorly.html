---
layout: post
title: 5 ways to Play! poorly
date: 2012-05-01 10:46:40.000000000 -05:00
categories:
- Anti-Patterns
- Play
tags:
- java
- netty
- play
status: publish
type: post
published: true
meta:
  _edit_last: '25054220'
  publicize_results: a:2:{s:7:"twitter";a:1:{i:109154946;a:2:{s:7:"user_id";s:12:"adamnengland";s:7:"post_id";s:18:"197351342677831680";}}s:2:"fb";a:1:{i:1471181839;a:2:{s:7:"user_id";s:10:"1471181839";s:7:"post_id";s:13:"3835148365150";}}}
  _wpas_done_twitter: '1'
  _wpas_done_fb: '1'
  _wpas_done_linkedin: '1'
author:
  login: adamnengland
  email: adam.n.england@gmail.com
  display_name: adamnengland
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>As readers may be aware, I'm really into the <a href="http://www.playframework.org/">Play!</a> framework. It combines the convention-over-configuration mindset of <a href="http://rubyonrails.org/">ROR</a> with the Java/Scala libraries and skills that I've worked on for years.</p>
<p>That said, Play! isn't idiot-proof. Here is a list of 5 mistakes to avoid in your Play! projects.</p>
<p><strong>1) Using Modules too liberally</strong></p>
<p><strong></strong>Play modules are great, but they can lead you to develop your projects as if you were still in the same Java world you'd always been in.  For example, when developing a REST api in Play, I started by installing the <a href="http://www.playframework.org/modules/resteasy">RestEasy Module</a>  It seemed like a no-brainer - an easy way to implement JAX-RS services.  However, after a bit of development, it became clear that one can obtain all the RESTful goodness by simply using <a href="http://www.playframework.org/documentation/1.2.4/routes">Play routes</a>  There is no reason to deal with increased build times, increased deployment size.</p>
<p>If you need the functionality of a specific module, by all means, include it.  However, spend the extra 5 minutes to see whether the functionality you need is provided in core Play first.</p>
<p><strong>2) Not considering the Scala/Java decision closely enough</strong></p>
<p>This is most relevant if you are working in Play! 1.x.  If you are in Play 2.0, its easy - use scala, please.  However, it can be appealing to use Java for play 1.x projects.  However, I tend to think that it is a bad idea.  The Play! development team is clearly moving towards Scala as the primary language, and it seems like a good idea to start with Scala in your 1.2 projects now.  It should make the 1.2 to 2.0 upgrade that much easier when you are ready.  I expect to have another entry for my readers in a few weeks with some tips on the 1.2 upgrade process.</p>
<p><strong>3) Building a War</strong></p>
<p>Any Java developer knows this cycle.  Build an application, package it into a war, deploy the war to an application server.  Play allows you to use this familiar cycle, and they support <a href="http://www.playframework.org/documentation/1.2.1/deployment">lots of popular app servers</a>.  That said, think carefully before you go this route.  The <em>play server</em> and <em>play run </em>commands bring up a standalone server using <a href="http://netty.io/">Netty</a>.  It is fast, simple, and perhaps most importantly, ensures that you are running your application in the same method for both development and production.</p>
<p><strong>4) Fail to worry about Template Performance</strong></p>
<p>Play is fast.  The JVM is a very optimized platform, and play takes advantage of that.  However, play has its Achilles heel -  Groovy Template rendering. I know it, you know it, the play dev team <a href="http://www.playframework.org/documentation/1.2/faq#aIsPlayfasta">knows it</a>.  Luckily, there are a lot of easy ways to fix this problem is performance is a concern in your app.</p>
<ol>
<li>Try one of the many alternate templating engines.  <a href="http://www.playframework.org/modules/fastergt">FasterGt</a>, <a href="http://www.playframework.org/modules/japid">Japid</a> or <a href="http://www.playframework.org/modules/rythm">Rythm</a> all provide much better speed.</li>
<li>Try Play! 2.0.  The template system has been moved to Scala, which shouldn't have any of the performance issues.</li>
<li>Go Client-Side.  Play! makes a great REST server, and if you combine it with a client-side MVC framework like <a href="http://javascriptmvc.com/">jmvc</a> or <a href="http://documentcloud.github.com/backbone/">backbone</a>, you can avoid the overhead of server-side template compilation.</li>
</ol>
<p><strong>5) Using Getters &amp; Setters</strong></p>
<p>Play! provides a wonderful piece of functionality called <a href="http://www.playframework.org/documentation/1.2.4/model">properties simulation</a>.  I won't rehash the details here - in short, Play! allows us to get away from one of Java's most annoying flaws.  Languages that we've come to love such as Ruby, Python, and JavaScript all make do without getters &amp; setters.  Try as I might, I can't think of any compelling reason that we should use them for every little property in our Java code.  I know it can be a little uncomfortable at first to buck the Java conventions and make your members public.  Trust me, once you get used to seeing those concise, clean models, you'll love it.</p>
<p>There you have it, 5 Play! framework anti-patterns.  Please comment if you have any anti-patterns of your own to share.</p>
