---
layout: post
title: 'Benchmarks: acts-as-taggable-on vs PostgreSQL Arrays'
date: 2014-02-19 12:40:54.000000000 -06:00
categories:
- Rails
tags:
- benchmark
- performance
- postgres
- rails
- ruby
- sourcecode
status: publish
type: post
published: true
meta:
  _edit_last: '25054220'
  _publicize_pending: '1'
  publicize_facebook_url: https://facebook.com/10203275224029319
  publicize_linkedin_url: http://www.linkedin.com/updates?discuss=&scope=22010808&stype=M&topic=5841974504305213440&type=U&a=FkNN
  _wpas_done_5885047: '1'
  _publicize_done_external: a:1:{s:8:"facebook";a:1:{i:1471181839;b:1;}}
  publicize_twitter_user: adamnengland
  publicize_twitter_url: http://t.co/GzPTGUyPpm
  _wpas_done_881586: '1'
  _wpas_done_881584: '1'
  publicize_tumblr_url: http://adamnengland.tumblr.com.tumblr.com/post/77191790660
  _wpas_done_4227152: '1'
author: Adam N England
---
While looking at performance optimizations for a rails project, I noticed these lines in my debug console:</p>

{% highlight bash %}
  ActsAsTaggableOn::Tag Load (0.5ms)  SELECT "tags".* FROM "tags" INNER JOIN "taggings" ON "tags"."id" = "taggings"."tag_id" WHERE "taggings"."taggable_id" = $1 AND "taggings"."taggable_type" = $2 AND (taggings.context = ('tags'))  [["taggable_id", 103], ["taggable_type", "Prediction"]]
{% endhighlight %}

<p>This makes sense, my project is using <a href="https://github.com/mbleigh/acts-as-taggable-on">acts-as-taggable-on</a> to tag models.  However, our tagging needs are quite simple, and since we are using postgres, I wondered whether using postgres array types might be more efficient.  To get a feel for the basic concept, see 41 studio's <a href="http://blog.41studio.com/2013/12/14/tagging-in-rails-4-using-postgresql-arrays/">writeup</a>.</p>
<p>However, before going through all the trouble, I'd like to see if the performance gains are appreciable or not.  Using rails benchmark functionality, we can do this pretty easily.</p>
<p>Full source code is available at https://github.com/adamnengland/rails-tag-bench, or follow along for the step by step for the full experience.</p>
<p><strong>Getting Started</strong><br />
You'll need</p>
<ul>
<li>Rails 4.0.2</li>
<li>Ruby 2.0.0</li>
<li>Postgres.app on OS X - though you can certainly modify this to work with any postgres install</li>
</ul>
<p><strong>Create a new Rails project</strong><br />

{% highlight bash %}
rails new rails-tag-bench
cd rails-tag-bench
{% endhighlight %}

<p>Open gemfile and add<br />
gem 'pg', '0.17.1'</p>
<p>(I had to do this first:  gem install pg -- --with-pg-config=/Applications/Postgres93.app/Contents/MacOS/bin/pg_config)</p>
<p>Then bundle install to get your dependencies.</p>
<p>Replace config/database.yml with<br />
{% highlight ruby linenos %}
development:
  adapter: postgresql
  encoding: unicode
  database: rails_tag_bench
  pool: 5
  username: rails_tag_bench
  password:
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000
production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000
{% endhighlight %}
<p>We'll need a database user, so open up postgres and issue:
{% highlight bash %}
create user rails_tag_bench with SUPERUSER;
{% endhighlight %}</p>
<p>Okay, lets create the database</p>
<p>{% highlight bash %}
rake db:create
{% endhighlight %}</p>
<p>In postgres type
\c rails_tag_bench
to confirm that the database is set up.</p>
<p>To do this, we'll also need acts-as-taggable-on, so update the gemfile</p>
<p>gem 'acts-as-taggable-on', '2.4.1'</p>
<p>and bundle install</p>
<p>{% highlight bash %}
rails g acts_as_taggable_on:migration
rake db:migrate
{% endhighlight %}</p>
<p>Lets start with the taggable version:<br />
{% highlight bash %}
rails g model ArticleTaggable title:string body:text
rake db:migrate
{% endhighlight %}
<p>open the created article_taggable.rb and edit<br />
{% highlight ruby %}
class ArticleTaggable < ActiveRecord::Base
  acts_as_taggable
end
{% endhighlight %}</p>
<p>Lets setup the benchmark:<br />
{% highlight bash %}
rails g task bench
{% endhighlight %}</p>
<p>Fill out the body like so</p>
<p>{% highlight ruby linenos %}
require 'benchmark'
namespace :bench do
  task writes: :environment do
    Benchmark.bmbm do |x|
      x.report("Benchmark 1") do
        1_000.times do
          ArticleTaggable.create(:title => ('a'..'z').to_a.shuffle[0,8].join, :body => ('a'..'z').to_a.shuffle[0,100].join, :tag_list =>; ['TAG1'])
        end
      end
    end
  end
  task reads: :environment do
    Benchmark.bmbm do |x|
      x.report("Benchmark 1") do
        1_000.times do<br />
          ArticleTaggable.includes(:tags).find_by_id(Random.new.rand(1000..2000));
        end
      end
    end
  end
end
{% endhighlight %}</p>
<p>You can run the benchmarks like so:</p>
<p>{% highlight bash %}
rake db:reset
rake bench:writes
rake bench:reads
{% endhighlight %}</p>
<p>Which should give you output like this:</p>
{% highlight bash %}
➜  rails-tag-bench  rake bench:writes
Rehearsal -----------------------------------------------
Benchmark 1   8.620000   0.340000   8.960000 ( 10.716852)
-------------------------------------- total: 8.960000sec
                  user     system      total        real
Benchmark 1   8.540000   0.320000   8.860000 ( 10.543746)

➜  rails-tag-bench  rake bench:reads
Rehearsal -----------------------------------------------
Benchmark 1   2.930000   0.160000   3.090000 (  3.906484)
-------------------------------------- total: 3.090000sec
                  user     system      total        real
Benchmark 1   2.880000   0.150000   3.030000 (  3.825437)
{% endhighlight %}

<p>So, on my macbook air, we wrote 1000 records in 10.5437 seconds, and read 1000 records in 3.8254 seconds with acts-as-taggable-on</p>
<p>Now, lets implement the example using postgres arrays, and see where we land</p>
<p>{% highlight bash %}
rails g model ArticlePa title:string body:text tags:string
{% endhighlight %}</p>
<p>Edit the new migration as follows<br />

{% highlight ruby linenos %}
class CreateArticlePas < ActiveRecord::Migration
  def change
    create_table :article_pas do |t|
      t.string :title
      t.text :body
      t.string :tags, array: true, default: []
      t.timestamps
    end
  end
end
{% endhighlight %}

{% highlight bash %}
rake db:migrate
{% endhighlight %}

<p>update our benchmarking code:</p>

{% highlight ruby linenos %}
require 'benchmark'
namespace :bench do
  task writes: :environment do
    Benchmark.bmbm do |x|
      x.report("Using Taggable") do
        1_000.times do
          ArticleTaggable.create(:title => ('a'..'z').to_a.shuffle[0,8].join, :body => ('a'..'z').to_a.shuffle[0,100].join, :tag_list => ['TAG1'])
        end
      end
      x.report("Using Postgres Arrays") do
        1_000.times do
          ArticlePa.create(:title => ('a'..'z').to_a.shuffle[0,8].join, :body => ('a'..'z').to_a.shuffle[0,100].join, :tags => ['TAG1'])
        end
      end
    end
  end
  task reads: :environment do
    Benchmark.bmbm do |x|
      x.report("Using Taggable") do
        1_000.times do
          ArticleTaggable.includes(:tags).find_by_id(Random.new.rand(1000..2000));
        end
      end
      x.report("Using Postgres Arrays") do
        1_000.times do
          ArticlePa.find_by_id(Random.new.rand(1000..2000));
        end
      end
    end
  end
end
{% endhighlight %}

{% highlight bash %}
rake db:reset
rake bench:writes
rake bench:reads
{% endhighlight %}

<p><strong>The Results</strong>
{% highlight bash %}
➜  rails-tag-bench  rake bench:writes
Rehearsal ---------------------------------------------------------
Using Taggable          8.520000   0.330000   8.850000 ( 10.532700)
Using Postgres Arrays   1.460000   0.110000   1.570000 (  2.082705)
----------------------------------------------- total: 10.420000sec</p>
                            user     system      total        real
Using Taggable          8.340000   0.310000   8.650000 ( 10.221277)
Using Postgres Arrays   1.410000   0.110000   1.520000 (  2.012559)
➜  rails-tag-bench  rake bench:reads
Rehearsal ---------------------------------------------------------
Using Taggable          2.920000   0.160000   3.080000 (  3.898911)
Using Postgres Arrays   0.420000   0.060000   0.480000 (  0.700684)
------------------------------------------------ total: 3.560000sec
                            user     system      total        real
Using Taggable          2.870000   0.140000   3.010000 (  3.805598)
Using Postgres Arrays   0.400000   0.060000   0.460000 (  0.677917)
{% endhighlight %}
<p>For my money, the postgres arrays appear to be much faster, which comes as little surprise.  By cutting out all the additional joins, we greatly reduce the query time.</p>
<p>However, it is important to note that this isn't an apples-to-apples comparison.  Acts-As-Taggable-On provides a lot of functionality that simple arrays do not provide.  More importantly, this locks you into the postgres database, which may or may not be a problem for you.  However, if you really have simplistic tag needs, the performance improvements might be worth it.</p>
