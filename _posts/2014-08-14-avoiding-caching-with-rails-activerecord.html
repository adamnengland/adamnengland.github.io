---
layout: post
title: Avoiding Caching with Rails ActiveRecord
date: 2014-08-14 15:08:10.000000000 -05:00
categories:
- Rails
tags:
- activerecord
- postgres
- rails
status: publish
type: post
published: true
meta:
  _edit_last: '25054220'
  geo_public: '0'
  _publicize_pending: '1'
  publicize_facebook_url: https://facebook.com/10204620949391612
  _wpas_done_5885047: '1'
  _publicize_done_external: a:1:{s:8:"facebook";a:1:{i:1471181839;b:1;}}
  publicize_twitter_user: adamnengland
  publicize_twitter_url: http://t.co/E4l3epu14t
  _wpas_done_881586: '1'
  publicize_linkedin_url: http://www.linkedin.com/updates?discuss=&scope=22010808&stype=M&topic=5905776717640777728&type=U&a=F3oR
  _wpas_done_881584: '1'
  publicize_tumblr_url: http://adamnengland.tumblr.com.tumblr.com/post/94751146090
  _wpas_done_4227152: '1'
author:
  login: adamnengland
  email: adam.n.england@gmail.com
  display_name: adamnengland
  first_name: ''
  last_name: ''
excerpt: !ruby/object:Hpricot::Doc
  <p>Today, I came across a puzzling issue with Rails 4.1, ActiveRecord, and Postgres when trying to select random records from a database table.</p>
  <p>To demonstrate, let's use a simple social network API example. Clients will POST a list of user, and I'll "match" them to someone in my database.</p>
  <p>Easy enough, for testing purposes we can just select a random user from our "users" table in postgres to simulate a match.</p>
---
<p>Today, I came across a puzzling issue with Rails 4.1, ActiveRecord, and Postgres when trying to select random records from a database table.</p>
<p>To demonstrate, let's use a simple social network API example. Clients will POST a list of user, and I'll "match" them to someone in my database.</p>
<p>Easy enough, for testing purposes we can just select a random user from our "users" table in postgres to simulate a match.</p>
<p>{% highlight ruby %}<br />
contacts = [{:id =&gt; 1}, {:id =&gt; 2}, {:id =&gt; 3}, {:id =&gt; 4}]<br />
contacts.each do |c|<br />
  user = User.order('random()').first<br />
  c[:detail] = {:username =&gt; user.username}<br />
end<br />
{% endhighlight %}</p>
<p>Run that in our rails console, and good things happen.  Seems like we have some random users from my (small) database.<br />
{% highlight ruby %}<br />
[{:id=&gt;1, :detail=&gt;{:username=&gt;"adam5"}},<br />
 {:id=&gt;2, :detail=&gt;{:username=&gt;"adam1"}},<br />
 {:id=&gt;3, :detail=&gt;{:username=&gt;"adam11"}},<br />
 {:id=&gt;4, :detail=&gt;{:username=&gt;"adam5"}}]<br />
{% endhighlight %}</p>
<p>Let's move that code into a controller action.<br />
{% highlight ruby %}<br />
  def create<br />
    contacts = [{:id =&gt; 1}, {:id =&gt; 2}, {:id =&gt; 3}, {:id =&gt; 4}]<br />
    contacts.each do |c|<br />
      user = User.order('random()').first<br />
      c[:detail] = {:username =&gt; user.username}<br />
    end<br />
    render :json =&gt; contacts, :root =&gt; false<br />
  end<br />
{% endhighlight %}</p>
<p>Uh-oh. This time, we get a decidedly un-random response:<br />
{% highlight javascript %}<br />
[<br />
    {<br />
        "id": 1,<br />
        "detail": {<br />
            "username": "adam6"<br />
        }<br />
    },<br />
    {<br />
        "id": 2,<br />
        "detail": {<br />
            "username": "adam6"<br />
        }<br />
    },<br />
    {<br />
        "id": 3,<br />
        "detail": {<br />
            "username": "adam6"<br />
        }<br />
    },<br />
    {<br />
        "id": 4,<br />
        "detail": {<br />
            "username": "adam6"<br />
        }<br />
    }<br />
]<br />
{% endhighlight %}</p>
<p>Looking at the logs, we'll see this:<br />
{% highlight bash %}<br />
  User Load (0.7ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
  User Load (0.7ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
  CACHE (0.0ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
  CACHE (0.0ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
  CACHE (0.0ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
  CACHE (0.0ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
  CACHE (0.0ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
  CACHE (0.0ms)  SELECT  "users".* FROM "users"   ORDER BY random() LIMIT 1<br />
{% endhighlight %}</p>
<p>Rails caching, normally so useful, causes a problem in this situation.  No sweat.  You just need to use <a href="http://api.rubyonrails.org/classes/ActiveRecord/QueryCache/ClassMethods.html#method-i-uncached">ActiveRecord's uncached method.</a></p>
<p>Modifying the action to use uncached looks like this:<br />
{% highlight ruby %}<br />
  def create<br />
    contacts = [{:id =&gt; 1}, {:id =&gt; 2}, {:id =&gt; 3}, {:id =&gt; 4}]<br />
    contacts.each do |c|<br />
      User.uncached do<br />
        user = User.order('random()').first<br />
        c[:detail] = {:username =&gt; user.username}<br />
      end<br />
    end<br />
    render :json =&gt; contacts, :root =&gt; false<br />
  end<br />
{% endhighlight %}</p>
<p>The database query no longer gets cached for the duration of the "User.uncached" block, and a new query is executed for each iteration. The controller action now gives us some nice, randomized output.<br />
{% highlight javascript %}<br />
[<br />
    {<br />
        "id": 1,<br />
        "detail": {<br />
            "username": "adam3"<br />
        }<br />
    },<br />
    {<br />
        "id": 2,<br />
        "detail": {<br />
            "username": "adam3"<br />
        }<br />
    },<br />
    {<br />
        "id": 3,<br />
        "detail": {<br />
            "username": "adam4"<br />
        }<br />
    },<br />
    {<br />
        "id": 4,<br />
        "detail": {<br />
            "username": "adam1"<br />
        }<br />
    }<br />
]<br />
{% endhighlight %}</p>
