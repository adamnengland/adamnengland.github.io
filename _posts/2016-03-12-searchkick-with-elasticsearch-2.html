---
layout: post
title: Using Searchkick with Elastic Search 2.0
date: 2017-03-12 20:33:09.000000000 -05:00
categories:
- Rails
tags:
- elasticsearch
- searchkick
- rails
- ruby
status: publish
type: post
published: true
meta: {}
author:
  login: adamnengland
  email: adam.n.england@gmail.com
  display_name: adamnengland
  first_name: 'Adam'
  last_name: 'England'
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>I've been a fan of SearchKick for years - it provides a great interface to ElasticSearch from your Ruby code. Recently, however, performance had become an issue.  We were using the async updates, and our sidekiq queues were overloaded with ElasticSearch updates.</p>
<p>Luckily, the team behind SearchKick recently introduced a great feature to address this issue:  <a href="https://github.com/ankane/searchkick#queuing">queueing</a>.  Basically, your updates are stored on redis, rather than sending to ElasticSearch immediately.  Later, you call the update worker, and the updates are sent in a batch.  Very efficient for scaled applications</p>
<p>When upgrading to the gem, I ran into 2 problems.</p>
<ol>
  <li>ActiveRecord 5.0 is specified in the gemspec - This collided with my Rails 4 app.</li>
  <li>In my gemfile, the elastic-search gem got upgraded to 5.0</li>
</ol>
<p>If you are working in Rails 5 and using ElasticSearch 5, this is probably great.  But if your project isn't quite on the bleeding edge, you need to make a few adjustments. This worked for me:</p>
<p>Instead of just upgrading your current searchkick install like this:</p>
<p>{% highlight bash %}
  gem update searchkick
<p>{% endhighlight %}</p>




<p>{% highlight ruby %}</p>
<p>create_table "business", force: :cascade do |t|<br />
  t.binary   "logo"<br />
end</p>
<p>{% endhighlight %}</p>
<p>If you've lived with this for a while, you'll want to migrate your data, which could take hours or days.  To avoid the need for an outage, we'll do this migration in phases.</p>
<ol>
<li>Add a new field to hold the carrierwave reference</li>
<li>Override our attribute accessors to read/write from either location</li>
</ol>
<p>Lets start with a schema migration to add the carrierwave support, and wire it up to our model.</p>
<p>{% highlight ruby %}<br />
class AddRenderedBodyFileToEventDocument &lt; ActiveRecord::Migration<br />
  def change<br />
    add_column :event_documents, :rendered_body_file, :string<br />
  end<br />
end</p>
<p>class Business &lt; ActiveRecord:Base<br />
  mount_uploader :logo_file, BusinessLogoFileUploader<br />
end</p>
<p># app/uploaders/business_logo_file_uploader.rb</p>
<p>class BusinessLogoFileUploader &lt; CarrierWave::Uploader::Base<br />
  storage :file</p>
<p>   def store_dir<br />
     "uploads/#{model.class.to_s.underscore}/#{mounted_as}/#{model.id}"<br />
   end</p>
<p>end<br />
{% endhighlight %}</p>
<p>Now, we need some way to convert from the database binary storage to carrierwave.  We add a method to our model to wrap this concept.</p>
<p>{% highlight ruby %}<br />
class Business &lt; ActiveRecord:Base<br />
  mount_uploader :logo_file, BusinessLogoFileUploader</p>
<p>  def convert_to_carrierwave<br />
    tempfile = Tempfile.new("business_#{id}")<br />
    tempfile.binmode<br />
    tempfile &lt;&lt; rendered_body<br />
    tempfile.rewind<br />
    self.rendered_body_file = tempfile<br />
    self.save!<br />
    tempfile.close<br />
    tempfile.delete<br />
  end<br />
end</p>
<p>{% endhighlight %}</p>
